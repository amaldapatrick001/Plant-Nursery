{% extends 'partials/base.html' %}
{% load static %}

{% block content %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garden Planner</title>
    <style>
        #garden-planner {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 0 20px;
            flex-wrap: wrap;
        }

        .main-content {
            display: flex;
            gap: 20px;
            flex: 1;
            min-width: 0;
        }

        .canvas-container {
            flex: 1;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            position: relative;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #plot-canvas {
            position: absolute;
            left: 0;
            top: 0;
        }

        #plant-list {
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            max-height: 600px;
            overflow-y: auto;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            order: -1; /* This moves the plant list to the left */
        }

        .plant-item {
            cursor: grab;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            background-color: #ffffff;
            width: 100%;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .plant-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-color: #4CAF50;
        }

        .plant-item img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            mix-blend-mode: multiply;
            background-color: transparent;
        }

        .plant-list-header {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .field-container {
            margin-bottom: 15px;
        }

        .hidden {
            display: none;
        }

        #layout-form-container {
            margin-bottom: 20px;
        }

        .dimensions-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
        }

        .distance-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            color: #333;
            border: 1px solid #ddd;
        }

        #previous-layouts {
            flex: 0 0 250px;
            margin: 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .previous-layouts-header {
            background-color: #2196F3;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .layout-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .layout-card {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: white;
        }

        .layout-card:hover {
            transform: translateX(-5px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border-color: #2196F3;
        }

        .layout-card.selected {
            border-color: #2196F3;
            background-color: #e3f2fd;
        }

        .layout-preview {
            width: 100%;
            height: 120px;
            object-fit: cover;
            margin-bottom: 8px;
            background-color: #f5f5f5;
        }

        .action-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .action-button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .save-button {
            background-color: #4CAF50;
            color: white;
        }

        .save-button:hover {
            background-color: #45a049;
        }

        .new-button {
            background-color: #2196F3;
            color: white;
        }

        .new-button:hover {
            background-color: #1e88e5;
        }

        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }

        .zoom-button {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 16px;
            color: #333;
            transition: all 0.3s ease;
        }

        .zoom-button:hover {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .zoom-button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .zoom-level {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
        }
    </style>



</head>
<body>
    <div class="hero-wrap hero-bread" style="background-image: url('{% static 'images/nur3.jpeg' %}');">
        <div class="container">
            <div class="row no-gutters slider-text align-items-center justify-content-center">
                <div class="col-md-9 ftco-animate text-center">
                    <p class="breadcrumbs"><span class="mr-2"><a href="">Home</a></span> <span>Garden Layout</span></p>
                    <h1 class="mb-0 bread">Design Your Garden Layout</h1>
                </div>
            </div>
        </div>
    </div>
    
    <div class="action-buttons">
        <button class="action-button new-button" id="newLayoutBtn">Create New Layout</button>
        <button class="action-button save-button" id="saveLayoutBtn">Save Current Layout</button>
    </div>

    <div id="layout-form-container" class="hidden">
        <form method="post" enctype="multipart/form-data" id="layoutForm">
        {% csrf_token %}
            {% for field in form %}
                <div class="field-container {% if field.name == 'plot_image' %}background-field image-field{% elif field.name == 'background_color' %}background-field color-field{% endif %}">
                    {{ field.label_tag }}
                    {{ field }}
                    {% if field.help_text %}
                        <small class="help-text">{{ field.help_text }}</small>
                    {% endif %}
                    {% if field.errors %}
                        <div class="error-message">{{ field.errors }}</div>
                    {% endif %}
                </div>
            {% endfor %}
            <button type="submit">Create Layout</button>
    </form>
    </div>

    <div id="garden-planner">
        <div class="main-content">
        <div id="plant-list">
                <div class="plant-list-header">Available Plants</div>
            {% for plant in plants %}
                    <div class="plant-item" 
                         data-plant-id="{{ plant.id }}" 
                         data-plant-name="{{ plant.name }}" 
                         data-min-spacing="{{ plant.min_spacing|default:1 }}"
                         draggable="true">
                    <img src="{{ plant.image.url }}" alt="{{ plant.name }}">
                        <span>{{ plant.name }} (Min: {{ plant.min_spacing|default:1 }}m)</span>
                    </div>
                {% endfor %}
            </div>
            <div class="canvas-container">
                <canvas id="plot-canvas"></canvas>
                <div class="dimensions-overlay"></div>
                <div class="zoom-controls">
                    <button class="zoom-button" id="zoomIn">+</button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="zoom-button" id="zoomOut">-</button>
                    <button class="zoom-button" id="resetZoom">Reset</button>
                    <button class="zoom-button" id="panButton" title="Click to toggle pan mode">ðŸ¤š</button>
                </div>
            </div>
        </div>
        <div id="previous-layouts">
            <div class="previous-layouts-header">Previous Layouts</div>
            <div class="layout-list">
                {% for layout in previous_layouts %}
                    <div class="layout-card" data-layout-id="{{ layout.id }}">
                        {% if layout.plot_image %}
                            <img src="{{ layout.plot_image.url }}" alt="{{ layout.layout_name }}" class="layout-preview">
                        {% else %}
                            <div class="layout-preview" style="background-color: {% if layout.background_color %}{{ layout.background_color }}{% else %}#f5f5f5{% endif %}"></div>
                        {% endif %}
                        <div>{{ layout.layout_name }}</div>
                        <div>{{ layout.plot_width }}m Ã— {{ layout.plot_length }}m</div>
                        <div>Created: {{ layout.created_at|date:"M d, Y" }}</div>
                </div>
            {% endfor %}
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
    <script>
        // Initialize Fabric.js canvas
        const canvas = new fabric.Canvas('plot-canvas', {
            width: 800,
            height: 600,
            selection: false
        });

        // Add these variables at the start of your script
        let currentZoom = 1;
        const ZOOM_STEP = 0.1;
        const MAX_ZOOM = 3;
        const MIN_ZOOM = 0.5;

        // Function to update canvas with layout details
        function updateCanvasWithLayout(layoutDetails) {
            // Clear existing canvas content
            canvas.clear();

            // Calculate canvas dimensions based on layout dimensions
            const canvasContainer = document.querySelector('.canvas-container');
            const containerWidth = 800;
            const containerHeight = 600;
            const layoutAspectRatio = layoutDetails.width / layoutDetails.length;
            
            let canvasWidth, canvasHeight;
            if (layoutAspectRatio > containerWidth / containerHeight) {
                canvasWidth = containerWidth;
                canvasHeight = containerWidth / layoutAspectRatio;
            } else {
                canvasHeight = containerHeight;
                canvasWidth = containerHeight * layoutAspectRatio;
            }

            // Update canvas size
            canvas.setWidth(canvasWidth);
            canvas.setHeight(canvasHeight);

            // Update background based on type
            if (layoutDetails.background_type === 'image' && layoutDetails.image_url) {
                fabric.Image.fromURL(layoutDetails.image_url, function(img) {
                    const scale = Math.min(
                        canvasWidth / img.width,
                        canvasHeight / img.height
                    );

                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                        scaleX: scale,
                        scaleY: scale,
                        originX: 'center',
                        originY: 'center',
                        left: canvasWidth / 2,
                        top: canvasHeight / 2
                    });

                    // Add grid overlay
                    addGridOverlay(canvasWidth, canvasHeight);
                    // Update dimensions display
                    updateDimensionsDisplay(layoutDetails.width, layoutDetails.length);
                });
            } else if (layoutDetails.background_type === 'color') {
                canvas.setBackgroundColor(layoutDetails.background_color, function() {
                    // Add grid overlay
                    addGridOverlay(canvasWidth, canvasHeight);
                    // Update dimensions display
                    updateDimensionsDisplay(layoutDetails.width, layoutDetails.length);
                    canvas.renderAll();
                });
            }
            updateZoom(1); // Reset zoom when loading new layout
        }

        // Function to add grid overlay
        function addGridOverlay(width, height) {
            const gridSize = Math.min(width, height) / 20;
            const gridColor = '#ddd';
            const gridOpacity = 0.5;

                    for (let i = 0; i < width; i += gridSize) {
                canvas.add(new fabric.Line([i, 0, i, height], {
                    stroke: gridColor,
                    opacity: gridOpacity,
                    selectable: false
                }));
                    }
                    for (let i = 0; i < height; i += gridSize) {
                canvas.add(new fabric.Line([0, i, width, i], {
                    stroke: gridColor,
                    opacity: gridOpacity,
                    selectable: false
                }));
            }
        }

        // Function to update dimensions display
        function updateDimensionsDisplay(width, length) {
            const dimensionsOverlay = document.querySelector('.dimensions-overlay');
            dimensionsOverlay.textContent = `${width}m Ã— ${length}m`;
        }

        // Handle form submission
        document.getElementById('layoutForm').addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);

            fetch('', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Update canvas with layout details
                    updateCanvasWithLayout(data.layout_details);
                    
                    // Store layout ID
                    document.getElementById('garden-planner').dataset.layoutId = data.layout_id;
                    
                    // Show success message
                    alert('Layout created successfully! You can now add plants.');
                } else {
                    let errorMessage = 'Error creating layout: ';
                    if (data.errors) {
                        errorMessage += Object.values(data.errors).join(', ');
                    } else {
                        errorMessage += 'Unknown error occurred';
                    }
                    alert(errorMessage);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to create layout. Please try again.');
            });
        });

        // Handle background type change
        document.querySelector('[name="background_type"]').addEventListener('change', function() {
            const imageField = document.querySelector('.image-field');
            const colorField = document.querySelector('.color-field');
            
            if (this.value === 'image') {
                imageField.classList.remove('hidden');
                colorField.classList.add('hidden');
            } else {
                imageField.classList.add('hidden');
                colorField.classList.remove('hidden');
            }
        });

        // Function to check minimum spacing between plants
        function checkPlantSpacing(currentPlant, x, y) {
            const plants = canvas.getObjects().filter(obj => obj !== currentPlant && obj.plantId);
            let hasMinimumSpace = true;
            
            plants.forEach(plant => {
                const dx = plant.left - x;
                const dy = plant.top - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Convert canvas distance to meters based on layout dimensions
                const canvasWidth = canvas.getWidth();
                const layoutWidth = parseFloat(document.querySelector('.dimensions-overlay').textContent.split('Ã—')[0]);
                const metersPerPixel = layoutWidth / canvasWidth;
                const distanceInMeters = distance * metersPerPixel;
                
                // Get minimum spacing for both plants
                const plant1Element = document.querySelector(`[data-plant-id="${plant.plantId}"]`);
                const plant2Element = document.querySelector(`[data-plant-id="${currentPlant.plantId}"]`);
                const minSpacing1 = parseFloat(plant1Element.dataset.minSpacing || 0);
                const minSpacing2 = parseFloat(plant2Element.dataset.minSpacing || 0);
                const requiredSpacing = Math.max(minSpacing1, minSpacing2);
                
                if (distanceInMeters < requiredSpacing) {
                    hasMinimumSpace = false;
                    plant.set('stroke', 'red');
                    plant.set('strokeWidth', 10);
                } else {
                    plant.set('stroke', null);
                    plant.set('strokeWidth', 0);
                }
            });
            
            return hasMinimumSpace;
        }

        // Update plant list items to include minimum spacing data
        document.querySelectorAll('.plant-item').forEach(function(plant) {
            const plantName = plant.querySelector('span').textContent;
            const minSpacing = plant.dataset.minSpacing;
            if (minSpacing) {
                plant.querySelector('span').textContent = `${plantName} (Min: ${minSpacing}m)`;
            }
        });

        // Function to calculate and display distances between plants
        function updateDistanceLabels() {
            // Remove existing distance labels and lines
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'text' && obj.distanceLabel || obj.type === 'line' && obj.distanceLine) {
                    canvas.remove(obj);
                }
            });

            const plants = canvas.getObjects().filter(obj => obj.plantId);
            const selectedPlant = canvas.getActiveObject();
            
            // Function to check if a plant is the closest neighbor in a given direction
            function isClosestNeighbor(plant1, plant2, plants) {
                const dx = plant2.left - plant1.left;
                const dy = plant2.top - plant1.top;
                const isHorizontal = Math.abs(dy) < 10; // 10px tolerance
                const isVertical = Math.abs(dx) < 10; // 10px tolerance
                
                if (!isHorizontal && !isVertical) return false;
                
                // Check if there's any plant between these two
                return !plants.some(otherPlant => {
                    if (otherPlant === plant1 || otherPlant === plant2) return false;
                    
                    const dx1 = otherPlant.left - plant1.left;
                    const dy1 = otherPlant.top - plant1.top;
                    const dx2 = plant2.left - otherPlant.left;
                    const dy2 = plant2.top - otherPlant.top;
                    
                    if (isHorizontal) {
                        return Math.abs(dy1) < 10 && // Same line
                               ((dx1 > 0 && dx2 > 0) || (dx1 < 0 && dx2 < 0)) && // Between the two plants
                               Math.abs(dx1) < Math.abs(dx); // Closer than plant2
                    } else {
                        return Math.abs(dx1) < 10 && // Same line
                               ((dy1 > 0 && dy2 > 0) || (dy1 < 0 && dy2 < 0)) && // Between the two plants
                               Math.abs(dy1) < Math.abs(dy); // Closer than plant2
                    }
                });
            }
            
            // Create distance labels and lines between plants
            for (let i = 0; i < plants.length; i++) {
                for (let j = i + 1; j < plants.length; j++) {
                    const plant1 = plants[i];
                    const plant2 = plants[j];
                    
                    // Calculate distance in pixels
                    const dx = plant2.left - plant1.left;
                    const dy = plant2.top - plant1.top;
                    const distanceInPixels = Math.sqrt(dx * dx + dy * dy);
                    
                    // Only show distance if:
                    // 1. A plant is selected and it's one of these plants, OR
                    // 2. No plant is selected and plants are neighboring in a straight line
                    const shouldShowDistance = selectedPlant ? 
                        (selectedPlant === plant1 || selectedPlant === plant2) :
                        isClosestNeighbor(plant1, plant2, plants);
                    
                    if (shouldShowDistance) {
                        // Convert to meters using the canvas scale
                        const canvasWidth = canvas.getWidth();
                        const layoutWidth = parseFloat(document.querySelector('.dimensions-overlay').textContent.split('Ã—')[0]);
                        const metersPerPixel = layoutWidth / canvasWidth;
                        const distanceInMeters = (distanceInPixels * metersPerPixel).toFixed(2);
                        
                        // Calculate label position (midpoint between plants)
                        const labelLeft = (plant1.left + plant2.left) / 2;
                        const labelTop = (plant1.top + plant2.top) / 2;

                        // Create line between plants
                        const line = new fabric.Line([plant1.left, plant1.top, plant2.left, plant2.top], {
                            stroke: 'black',
                            strokeWidth: 1,
                            strokeDashArray: selectedPlant ? [5, 5] : null, // Only dotted if plant is selected
                            selectable: false,
                            evented: false,
                            distanceLine: true,
                            originX: 'center',
                            originY: 'center'
                        });
                        
                        // Create and add distance label with white background
                        const label = new fabric.Text(`${distanceInMeters}m`, {
                            left: labelLeft,
                            top: labelTop,
                            fontSize: 14,
                            fill: '#333',
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            padding: 4,
                            originX: 'center',
                            originY: 'center',
                            distanceLabel: true,
                            selectable: false,
                            evented: false
                        });

                        // Add line first so it appears behind the label
                        canvas.add(line);
                        canvas.add(label);
                    }
                }
            }
            
            // Bring all plants to front
            plants.forEach(plant => plant.bringToFront());
            canvas.renderAll();
        }

        // Add selection event handler to update distances
        canvas.on('selection:created', function(e) {
            updateDistanceLabels();
        });

        canvas.on('selection:cleared', function(e) {
            updateDistanceLabels();
        });

        // Modify the drop event handler to update distances
        canvas.on('drop', function(event) {
            const plantId = event.e.dataTransfer.getData('text/plain');
            const plant = document.querySelector(`[data-plant-id="${plantId}"]`);
            const plantName = plant.dataset.plantName;
            const plantImageUrl = plant.querySelector('img').src;

            fabric.Image.fromURL(plantImageUrl, function(img) {
                const pointer = canvas.getPointer(event.e);
                const canvasWidth = canvas.getWidth();
                const standardSize = canvasWidth * 0.1;
                
                const scale = standardSize / Math.max(img.width, img.height);
                
                img.set({
                    left: pointer.x,
                    top: pointer.y,
                    selectable: true,
                    name: plantName,
                    plantId: plantId,
                    scaleX: scale,
                    scaleY: scale,
                    originX: 'center',
                    originY: 'center'
                });

                // Check spacing and update visual feedback
                const hasSpace = checkPlantSpacing(img, pointer.x, pointer.y);
                if (!hasSpace) {
                    img.set('stroke', 'red');
                    img.set('strokeWidth', 2);
                }

                canvas.add(img);
                updateDistanceLabels(); // Update distance labels after adding new plant
                canvas.renderAll();
            });
        });

        // Update distances when plants are moved
        canvas.on('object:moving', function(e) {
            const plant = e.target;
            if (plant.plantId) {
                const hasSpace = checkPlantSpacing(plant, plant.left, plant.top);
                if (!hasSpace) {
                    plant.set('stroke', 'red');
                    plant.set('strokeWidth', 2);
                } else {
                    plant.set('stroke', null);
                    plant.set('strokeWidth', 0);
                }
                updateDistanceLabels(); // Update distance labels while moving
                canvas.renderAll();
            }
        });

        // Update distances after movement ends
        canvas.on('object:modified', function(e) {
            if (e.target.plantId) {
                updateDistanceLabels();
            }
        });

        // Initialize drag and drop functionality
        canvas.on('dragover', function(e) {
            e.preventDefault();
        });

        // Add drag start event to plant items
        document.querySelectorAll('.plant-item').forEach(function(plant) {
            plant.addEventListener('dragstart', function(e) {
                e.dataTransfer.setData('text/plain', this.dataset.plantId);
            });
        });

        // Trigger background type change event on page load
        document.querySelector('[name="background_type"]').dispatchEvent(new Event('change'));

        // Function to load a previous layout
        function loadLayout(layoutId) {
            fetch(`/plant_layout/get-layout/${layoutId}/`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'error') {
                        throw new Error(data.error || 'Failed to load layout');
                    }
                    
                    // Clear existing canvas content
                    canvas.clear();

                    // Update canvas with layout details
                    updateCanvasWithLayout({
                        width: data.plot_width,
                        length: data.plot_length,
                        background_type: data.background_type,
                        background_color: data.background_color,
                        image_url: data.plot_image
                    });

                    // Store layout ID
                    document.getElementById('garden-planner').dataset.layoutId = layoutId;

                    // Load plant positions if they exist
                    if (data.plant_positions && data.plant_positions.plants) {
                        data.plant_positions.plants.forEach(plant => {
                            // Find the plant element to get the image URL
                            const plantElement = document.querySelector(`[data-plant-id="${plant.plantId}"]`);
                            if (plantElement) {
                                const plantImageUrl = plantElement.querySelector('img').src;
                                fabric.Image.fromURL(plantImageUrl, function(img) {
                                    const canvasWidth = canvas.getWidth();
                                    const standardSize = canvasWidth * 0.1; // Increased to 10% of canvas width
                                    const scale = standardSize / Math.max(img.width, img.height);
                                    
                                    img.set({
                                        left: plant.left,
                                        top: plant.top,
                                        selectable: true,
                                        name: plant.name,
                                        plantId: plant.plantId,
                                        scaleX: scale,
                                        scaleY: scale,
                                        angle: plant.angle || 0,
                                        originX: 'center',
                                        originY: 'center'
                                    });
                                    canvas.add(img);
                                });
                            }
                        });
                    }

                    // Hide the form container if it's visible
                    document.getElementById('layout-form-container').classList.add('hidden');

                    canvas.renderAll();
                    updateDistanceLabels(); // Add this line to update distances after loading
                })
                .catch(error => {
                    console.error('Error loading layout:', error);
                    alert('Failed to load layout. Please try again.');
                });
        }

        // Handle layout card clicks
        document.querySelectorAll('.layout-card').forEach(card => {
            card.addEventListener('click', function() {
                // Remove selection from other cards
                document.querySelectorAll('.layout-card').forEach(c => c.classList.remove('selected'));
                // Add selection to clicked card
                this.classList.add('selected');
                // Load the layout
                loadLayout(this.dataset.layoutId);
            });
        });

        // Handle new layout button
        document.getElementById('newLayoutBtn').addEventListener('click', function() {
            document.getElementById('layout-form-container').classList.remove('hidden');
            canvas.clear();
            document.getElementById('garden-planner').removeAttribute('data-layout-id');
        });

        // Handle save layout button
        document.getElementById('saveLayoutBtn').addEventListener('click', function() {
            const layoutId = document.getElementById('garden-planner').dataset.layoutId;
            if (!layoutId) {
                alert('Please create a layout first.');
                return;
            }

            const plantsOnCanvas = canvas.getObjects().map(obj => ({
                plantId: obj.plantId,
                name: obj.name,
                left: obj.left,
                top: obj.top,
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                angle: obj.angle || 0
            }));

            fetch(`/plant_layout/save-plant-positions/${layoutId}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ plant_positions: plantsOnCanvas })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    alert('Layout saved successfully!');
                } else {
                    throw new Error(data.message || 'Unknown error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to save layout: ' + error.message);
            });
        });

        // Function to update zoom while maintaining plant sizes
        function updateZoom(zoom) {
            // Limit zoom level
            zoom = Math.min(Math.max(zoom, MIN_ZOOM), MAX_ZOOM);
            
            // Store current plant scales and positions
            const plants = canvas.getObjects().filter(obj => obj.plantId);
            const originalPlants = plants.map(plant => ({
                id: plant.plantId,
                scaleX: plant.scaleX,
                scaleY: plant.scaleY,
                left: plant.left,
                top: plant.top
            }));
            
            // Set zoom level
            canvas.setZoom(zoom);
            
            // Adjust viewport transform to zoom from center
            const vpt = canvas.viewportTransform;
            const center = {
                x: canvas.width / 2,
                y: canvas.height / 2
            };
            
            vpt[4] = center.x - (center.x * zoom);
            vpt[5] = center.y - (center.y * zoom);
            
            // Restore original plant scales and adjust positions
            plants.forEach((plant, index) => {
                const original = originalPlants[index];
                if (original.id === plant.plantId) {
                    // Keep original scale
                    plant.scaleX = original.scaleX;
                    plant.scaleY = original.scaleY;
                    
                    // Adjust position relative to zoom center
                    plant.setCoords();
                }
            });
            
            // Update zoom level display
            currentZoom = zoom;
            document.getElementById('zoomLevel').textContent = `${Math.round(zoom * 100)}%`;
            
            // Render changes
            canvas.requestRenderAll();
            updateDistanceLabels();
        }

        // Add zoom controls event listeners
        document.getElementById('zoomIn').addEventListener('click', function() {
            updateZoom(currentZoom + ZOOM_STEP);
        });

        document.getElementById('zoomOut').addEventListener('click', function() {
            updateZoom(currentZoom - ZOOM_STEP);
        });

        document.getElementById('resetZoom').addEventListener('click', function() {
            updateZoom(1);
        });

        // Enhanced pan support with better cursor feedback
        let isPanning = false;
        let lastPosX;
        let lastPosY;
        const panButton = document.getElementById('panButton');

        // Function to toggle pan mode
        function togglePanMode() {
            isPanning = !isPanning;
            panButton.classList.toggle('active');
            
            canvas.forEachObject(function(obj) {
                if (obj.plantId) {
                    obj.selectable = true;  // Always keep plants selectable
                }
            });
            
            if (isPanning) {
                canvas.defaultCursor = 'grab';
                canvas.hoverCursor = 'grab';
                document.body.style.cursor = 'grab';
            } else {
                canvas.defaultCursor = 'default';
                canvas.hoverCursor = 'move';
                document.body.style.cursor = 'default';
            }
        }

        // Add pan button click handler
        panButton.addEventListener('click', togglePanMode);

        // Keep spacebar functionality as alternative
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && !isPanning) {
                e.preventDefault(); // Prevent page scroll
                togglePanMode();
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.code === 'Space' && isPanning) {
                togglePanMode();
            }
        });

        canvas.on('mouse:down', function(opt) {
            if (isPanning && (!opt.target || !opt.target.plantId)) {  // Only pan if not clicking on a plant
                opt.e.preventDefault();
                canvas.defaultCursor = 'grabbing';
                canvas.hoverCursor = 'grabbing';
                document.body.style.cursor = 'grabbing';
                const evt = opt.e;
                lastPosX = evt.clientX;
                lastPosY = evt.clientY;
            }
        });

        canvas.on('mouse:move', function(opt) {
            if (isPanning && opt.e.buttons === 1 && (!opt.target || !opt.target.plantId)) {  // Only pan if not dragging a plant
                const e = opt.e;
                const vpt = canvas.viewportTransform;
                vpt[4] += e.clientX - lastPosX;
                vpt[5] += e.clientY - lastPosY;
                canvas.requestRenderAll();
                lastPosX = e.clientX;
                lastPosY = e.clientY;
            }
        });

        canvas.on('mouse:up', function() {
            if (isPanning) {
                canvas.defaultCursor = 'grab';
                canvas.hoverCursor = 'grab';
                document.body.style.cursor = 'grab';
            }
        });

        // Add mouse hover effect for plants during pan mode
        canvas.on('mouse:over', function(opt) {
            if (isPanning && opt.target && opt.target.plantId) {
                canvas.defaultCursor = 'move';
                canvas.hoverCursor = 'move';
                document.body.style.cursor = 'move';
            }
        });

        canvas.on('mouse:out', function(opt) {
            if (isPanning && (!opt.target || !opt.target.plantId)) {
                canvas.defaultCursor = 'grab';
                canvas.hoverCursor = 'grab';
                document.body.style.cursor = 'grab';
            }
        });

        // Add mouse wheel zoom support with size preservation
        canvas.on('mouse:wheel', function(opt) {
            opt.e.preventDefault();
            opt.e.stopPropagation();
            
            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            
            updateZoom(zoom);
        });
    </script>
</body>
</html>
{% endblock %}